package main

import (
	"fmt"
	"log"
	"os"
	"sort"
	"strings"

	"github.com/rancher/norman/types/convert"
	"github.com/rancher/types/apis/management.cattle.io/v3"
	"github.com/rancher/types/image"
)

func main() {
	if err := run(os.Args[1:]...); err != nil {
		log.Fatal(err)
	}
}

func run(images ...string) error {
	targetImages, err := collectionImages(v3.K8sVersionToRKESystemImages, v3.ToolsSystemImages, v3.Arm64K8sVersionToRKESystemImages)
	if err != nil {
		return err
	}

	for _, i := range images {
		targetImages = append(targetImages, image.Mirror(i))
	}

	err = imagesText(targetImages)
	if err != nil {
		return err
	}

	err = mirrorScript(targetImages)
	if err != nil {
		return err
	}

	err = saveScript(targetImages)
	if err != nil {
		return err
	}

	return loadScript(targetImages)
}

func loadScript(targetImages []string) error {
	log.Println("Creating rancher-load-images.sh")
	load, err := os.Create("rancher-load-images.sh")
	if err != nil {
		return err
	}
	defer load.Close()
	load.Chmod(0755)

	fmt.Fprintf(load, `#!/bin/bash
list="rancher-images.txt"
images="rancher-images.tar.gz"

POSITIONAL=()
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -r|--registry)
        reg="$2"
        shift # past argument
        shift # past value
        ;;
        -l|--image-list)
        list="$2"
        shift # past argument
        shift # past value
        ;;
        -i|--images)
        images="$2"
        shift # past argument
        shift # past value
        ;;
        -h|--help)
        help="true"
        shift
        ;;
    esac
done

usage () {
    echo "USAGE: $0 [--image-list rancher-images.txt] [--images rancher-images.tar.gz] --registry my.registry.com:5000"
    echo "  [-l|--images-list path] text file with list of images. 1 per line."
    echo "  [-l|--images path] tar.gz generated by docker save."
    echo "  [-r|--registry registry:port] target private registry:port."
    echo "  [-h|--help] Usage message"
}

if [[ -z $reg ]]; then
    usage
    exit 1
fi
if [[ $help ]]; then
    usage
    exit 0
fi

set -e -x

docker load --input ${images}

for i in $(cat ${list}); do
    docker tag ${i} ${reg}/${i}
    docker push ${reg}/${i}
done
`)
	return nil
}

func saveImages(targetImages []string) []string {
	var saveImages []string
	for _, targetImage := range targetImages {
		_, ok := image.Mirrors[targetImage]
		if !ok {
			continue
		}

		saveImages = append(saveImages, targetImage)
	}
	return saveImages
}

func saveScript(targetImages []string) error {
	log.Println("Creating rancher-save-images.sh")
	save, err := os.Create("rancher-save-images.sh")
	if err != nil {
		return err
	}
	defer save.Close()
	save.Chmod(0755)

	fmt.Fprintf(save, `#!/bin/bash
list="rancher-images.txt"
images="rancher-images.tar.gz"

POSITIONAL=()
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -i|--images)
        images="$2"
        shift # past argument
        shift # past value
        ;;
        -l|--image-list)
        list="$2"
        shift # past argument
        shift # past value
        ;;
        -h|--help)
        help="true"
        shift
        ;;
    esac
done

usage () {
    echo "USAGE: $0 [--image-list rancher-images.txt] [--images rancher-images.tar.gz]"
    echo "  [-l|--images-list path] text file with list of images. 1 per line."
    echo "  [-l|--images path] tar.gz generated by docker save."
    echo "  [-h|--help] Usage message"
}

if [[ $help ]]; then
    usage
    exit 0
fi

set -e -x

for i in $(cat ${list}); do
    docker pull ${i}
done

docker save $(cat ${list} | tr '\n' ' ') | gzip -c > ${images}
`)

	return nil
}

func imagesText(targetImages []string) error {
	log.Println("Creating rancher-images.txt")
	save, err := os.Create("rancher-images.txt")
	if err != nil {
		return err
	}
	defer save.Close()
	save.Chmod(0755)

	for _, image := range saveImages(targetImages) {
		log.Println("Image:", image)
		fmt.Fprintln(save, image)
	}

	return nil
}

func mirrorScript(targetImages []string) error {
	log.Println("Creating rancher-mirror-to-rancher-org.sh")
	mirror, err := os.Create("rancher-mirror-to-rancher-org.sh")
	if err != nil {
		return err
	}
	defer mirror.Close()
	mirror.Chmod(0755)

	fmt.Fprintf(mirror, "#!/bin/sh\nset -e -x\n\n")

	var saveImages []string
	for _, targetImage := range targetImages {
		srcImage, ok := image.Mirrors[targetImage]
		if !ok {
			log.Printf("jh srcImage not ok. targetImage: %s", targetImage)
			continue
		}
		log.Printf("jh srcImage: %s targetImage: %s", srcImage, targetImage)

		saveImages = append(saveImages, targetImage)
		if isManifest(srcImage) {
			for _, arch := range image.ArchitectureList {
				src := manifestResolve(srcImage, arch)
				fmt.Fprintf(mirror, "docker pull %s\n", src)
				fmt.Fprintf(mirror, "docker tag %s %s-%s\n", src, targetImage, arch)
				fmt.Fprintf(mirror, "docker push %s-%s\n", targetImage, arch)
			}
			createManifest := fmt.Sprintf("docker manifest create %s ", targetImage)
			for _, arch := range image.ArchitectureList {
				createManifest = createManifest + fmt.Sprintf("%s-%s ", targetImage, arch)
			}
			fmt.Fprintf(mirror, "%s\n", createManifest)
			for _, arch := range image.ArchitectureList {
				fmt.Fprintf(mirror, "docker manifest annotate %s %s-%s --arch %s\n", targetImage, targetImage, arch, arch)
			}
			fmt.Fprintf(mirror, "docker manifest push -p %s\n", targetImage)
		} else {
			fmt.Fprintf(mirror, "docker pull %s\n", srcImage)
			if targetImage != srcImage {
				fmt.Fprintf(mirror, "docker tag %s %s\n", srcImage, targetImage)
				fmt.Fprintf(mirror, "docker push %s\n", targetImage)
			}
		}
	}

	return nil
}

func isManifest(srcImage string) bool {
	for _, image := range image.ManifestList {
		if image == srcImage {
			return true
		}
	}
	return false
}

func manifestResolve(srcImage string, architecture string) (src string) {
	src = ""
	if strings.Contains(srcImage, "quay.io") && strings.Contains(srcImage, "etcd") {
		if architecture == "amd64" {
			src = srcImage
		} else {
			src = fmt.Sprintf("%s-%s", srcImage, architecture)
		}
	} else if strings.Contains(srcImage, "quay.io") && !strings.Contains(srcImage, "etcd") {
		src = fmt.Sprintf("%s-%s", srcImage, architecture)
	} else if strings.Contains(srcImage, "gcr.io/google_containers") || strings.Contains(srcImage, "k8s.gcr.io") {
		imageStrs := strings.Split(srcImage, ":")
		src = fmt.Sprintf("%s-%s:%s", imageStrs[0], architecture, imageStrs[1])
	}
	return
}

func collectionImages(objs ...interface{}) ([]string, error) {
	images := map[string]bool{}

	for _, obj := range objs {
		data := map[string]interface{}{}
		if err := convert.ToObj(obj, &data); err != nil {
			return nil, err
		}
		findStrings(data, images)
	}

	var result []string
	for k := range images {
		result = append(result, k)
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i] < result[j]
	})

	return result, nil
}

func findStrings(obj map[string]interface{}, found map[string]bool) {
	for _, v := range obj {
		switch t := v.(type) {
		case string:
			found[t] = true
		case map[string]interface{}:
			findStrings(t, found)
		}
	}
}
